<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WEB开发面试畅谈（2）——内容安全策略CSP]]></title>
    <url>%2FWEB%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E7%95%85%E8%B0%88%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5CSP%2F</url>
    <content type="text"><![CDATA[什么是CSP？CSP是由单词 Content Security Policy 的首单词组成，CSP旨在减少(注意这里是减少而不是消灭)跨站脚本攻击。CSP是一种由开发者定义的安全性政策性申明，通过CSP所约束的的规责指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。通过CSP协定，让WEB处于一个安全的运行环境中。更多关于CSP的介绍可以参考W3C的相关文档： https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html#content-security-policy-header-field一部分中文翻译：CSP - HTML5 Chinese Interest Group Wiki(https://www.w3.org/html/ig/zh/wiki/CSP)CSP的讨论CSP的出现可以一定程度上的减少XSS的攻击，但不一定意味着XSS的消失。挺久之前过了一遍CSP的安全策略，很多人把它喻为XSS攻击的终结者，因为这种策略不再像传统只靠各种正则和特征匹配来识别跨站攻击Payload，而是直接从协议层把一些存在安全隐患的用法默认给干掉了，把同源同域更发挥到了极致。把之前整理的内容发到这里吧。 只允许本站资源Content-Security-Policy： default-src‘self’ 允许本站的资源以及任意位置的图片以及http://trustedscripts.example.com下的脚本。 Content-Security-Policy： default-src ‘self’；img-src *； script-src http://trustedscripts.example.com CSP策略在默认的情况下是不允许使用data URIs资源的,如果要使用，那么需要显示的指定,比如:img-src ‘self’ data: script-src：在处理脚本资源的时候设置”unsafe-inline”可以阻止内联Js代码的执行。使用unsafe-eval开关可以禁止eval,setTimeout,setInterval函数的执行。 object-src：控制embed,code,archive applet等对象。 style-src：会控制样式表@import和rel时所引入的URI资源，设置unsafe-inline规则可以是浏览器拒绝解析内部样式和内联样式定义。并不会阻止链入外部样式表。 img-src：可以控制图片资源的连接，包括img标签的src属性，以及CSS3中的url()和image()方法，以及link标签中的href属性(当rel设置成与图像相关的值，比如HTML支持的icon) media-src:控制媒体类型的外部链入资源，如video, audio, source, 和track标签的src属性。 frame-src:控制内嵌框架包含的外部页面连接：iframe or a frame。 font-src：控制CSS中的@font-face connect-src：控制XMLHttpRequest中的open()，WebSocket，EventSource inline script和eval类型函数(包括eval、setInterval、setTimeout和new Function())是不被执行的。另外data URIs也是默认不允许使用的，XBL,只允许通过chrome:和resource:形式uri请求的XBL,其它的比如在CSS中通过-moz-binding来指定的XBL则不允许被执行。 早期WEB开发的规范并不明确，为了向前兼容性，最新的浏览器仍兼容着最古老而且可能存在风险的语法和接口 。通俗的讲，CSP明确地告诉我们，哪些WEB开发行为对于宽松模式来说是可以使用的，但出于安全问题我们应尽早摒弃。我们不仅要做到实现更能，而且要更好更安全地实现。下面例举个CSP适用的实际场景，大家会一目了然CSP的约束内容 不执行Inline JavaScriptInline JavaScript和eval一样危险，将不会被执行。这条规则将同时禁止内嵌&lt; script &gt;块和内联事件（例如： &lt; button onclick=”…” &gt;;&lt; ahref=”javascript:…”&gt;）。这条规则通过禁止第三方脚本避免大量的跨脚本攻击。同时它还强制您编写内容与表现分离的代码（这本就是您该做的，对吧？）。用个例子说明这一点：假设您在一个单独的popup.html文件中实现如下Browser Action弹出页：1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Awesome Popup!&lt;/title&gt;&lt;script&gt;function awesome() &#123; // do something awesome! &#125;functiontotallyAwesome() &#123; // do something TOTALLY awesome! &#125;functionclickHandler(element) &#123;setTimeout(&quot;awesome(); totallyAwesome()&quot;, 1000); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button onclick=&quot;clickHandler(this)&quot;&gt; Click for awesomeness!&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;为了使它能以您所希望的方式运行，结合本规则，需要做以下三个方面的修改：· clickHandler的定义需移到外部JavaScript文件中（如：popup.js）。· 内联事件需通过addEventListener，并移到外部popup.js文件中实现。· 为了避免使用转换字符串到JavaScript的函数”awesome(); totallyAwesome()”的执行，setTimeout调用需要重写。修改之后将会像下面这样：popup.js:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function awesome() &#123; // Do something awesome! &#125;functiontotallyAwesome() &#123; // do something TOTALLY awesome! &#125; functionawesomeTask() &#123;awesome();totallyAwesome(); &#125; functionclickHandler(e) &#123;setTimeout(awesomeTask, 1000); &#125; // Add event listeners once the DOM has fully loaded by listening for the // `DOMContentLoaded` event on the document, and adding your listeners to // specific elements when it triggers.document.addEventListener(&apos;DOMContentLoaded&apos;, function () &#123;document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;, clickHandler); &#125;); popup.html:&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Awesome Popup!&lt;/title&gt;&lt;script src=&quot;popup.js&quot;&gt;&lt;/script&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;Click for awesomeness!&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 综述：首先CSP是可以在一定程度上提高XSS的攻击难度的，甚至杜绝XSS，前提是CSP策略用的好。还要考虑CSP能否普及，因为CSP在提供安全性的同时也提高了前端逻辑的复杂度，很多资源需要调整，类似QQ，新浪，搜狐这样的站群，想通过合适的CSP同时提高安全性和易用性是很难的。但是我们仍要尽可能使用更加规范的编码方式提高WEB开发的质量 目前CSP规范并未应用于全部浏览器，仅仅新浏览器会得到支持。但是遵循CSP规范开发的WEB应用将获得更好的代码结构和用户体验，大大提高安全性。这可能会彻底改变你之前的开发习惯和方式。甚至你会恍然发现，之前的代码是如此脆弱不堪。甚至会有些不适。但是，时代总是向前发展的。当你渐渐习惯并接受了它，才发现它带来的无尽好处，助你在web开发的道路上走得更快更好。]]></content>
      <tags>
        <tag>开发面谈</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB开发面试畅谈（1）——Javascript封闭性设计]]></title>
    <url>%2FWEB%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E7%95%85%E8%B0%88%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94Javascript%E5%B0%81%E9%97%AD%E6%80%A7%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[日常开发中，我们经常会提到模块化开发、代码规范等等，但到了以HTML和Javascript为首的WEB开发这里，一切都变了。 无论是HTML还是Javascript都以其松散的结构和宽松的规范极大降低了开发成本，但又同时引入了新的问题：不同的开发人员有着不同的开发习惯，当然这些习惯也有好有坏，大多数程序员只是坚持着”能运行就可以“的思想观念，而这些并不利于项目的长期发展。于WEB开发中松散的特性，许多思路和经验并不是语言层面约束的，而是通过特有的代码逻辑和结构加以维护。所以在观看下文时，请勿在评论中发表类似如下的评论：”搞那么复杂干嘛？直接var一个变量去改不就好了，干嘛用闭包，我自己写的代码自己清楚，我用人格担保我的调用正确“，扯远了，如果你认同我上面的大体思想，请继续往下看。 大多数开发人员在第一次开发WEB时，一定写过类似如下的代码:123var a = 1;var b = 2;alert(a+b); 我们欢呼着把脚步踏入了JS开发行列，并且意识到JS的强大，简单堆叠代码就能实现功能。但时到如今回头看这段代码，确实问题重重。提到此，我们已经不是关注功能实现的问题，而是设计的问题。功能是个人都能实现，但设计确实良莠不齐因人而异。以上述代码为例，我们仅仅需要实现alert(a+b)却同时生硬的在全局书写了两个全局变量a、b。而在其余地方这两个变量均无用。倘若另一段代码也没做封闭处理，也用全局a、b，很容易引发冲突问题，而且不是异常，难于定位。实现封闭，最简单的方式是定义闭包，闭包简而言之就是构造一个匿名函数并且立刻执行它。我们会得到执行结果，却不会将局部变量暴露给外层或全局。 优化后的代码12345(function() &#123; var a = 1; var b = 2; alert(a+b);&#125;)(); 简单构造的闭包语法，可以很方便地将非闭包语法加以封闭，在调试阶段，确保变量不冲突的前提下，可将首尾行注释，方便在Chrome等开发工具中调试12345//(function() &#123; var a = 1; var b = 2; alert(a+b);//&#125;)(); 封闭性是一个良好代码设计的开始，闭包内的变量默认是私有（这里不考虑不用var声明的全局变量，参照JS代码规范）。我们可以选择性地在闭包的结尾将公开成员公开出去。1234567(function() &#123; var pageOpenTime = new Date(); function getPageOpenTime() &#123; return pageOpenTime; &#125; window.getPageOpenTime = getPageOpenTime;&#125;)(); 但也不是教条主义。比如我们要定义一组API，其实可以这么实现但按照前面的规范，getNow()与getPageOpenTime()是互相独立的，而且getNow()中理应无法调用pageOpenTime。代码该写成这样：1234567891011121314(function() &#123; var pageOpenTime = new Date(); function getPageOpenTime() &#123; return pageOpenTime; &#125; window.getPageOpenTime = getPageOpenTime;&#125;)();(function()&#123; function getNow() &#123; return new Date(); &#125; window.getNow = getNow;&#125;)(); 那么恭喜你，你已经犯了教条主义。也就是过度设计。我们实现的API内部是几乎不可能被外界干预的。没必要设过于复杂的限制约束，不论复杂度还是维护都麻烦。这又是与封闭性互为反面的，如何权衡呢？我们只需要保证对外公开的接口严格准确，内部是可以更灵活一些的。即便丧失了局部封闭性，但对外接口还是封闭的。而且也更加灵活。 那么我们最终实现的代码如下即可。1234567891011(function() &#123; var pageOpenTime = new Date(); function getPageOpenTime() &#123; return pageOpenTime; &#125; function getNow() &#123; return new Date(); &#125; window.getPageOpenTime = getPageOpenTime; window.getNow = getNow;&#125;)(); 再深入思考一下，我们把一坨函数直接暴露给window真的好么？倘若我们有100个函数，不敢想象。。我们需要做一个包装对象1234567891011121314(function() &#123; var pageOpenTime = new Date(); function getPageOpenTime() &#123; return pageOpenTime; &#125; function getNow() &#123; return new Date(); &#125; var TimeTools = &#123; getPageOpenTime: getPageOpenTime, getNow: getNow &#125;; window.TimeTools = TimeTools&#125;)(); 这样就保证全局只有唯一一个暴露对象了。 那我们继续深入，万一有另外一个人也蛋疼的起了个叫TimeTools的全局变量，咋办？？？继续冲突中我想说，非要把人往死路逼么？好吧，那我也拿出看家本领。参见jQuery.noConflict()方法大意就是在赋值全局变量时，先保存之前版本的全局变量，如果冲突，可以调用noConflict()方法回滚全局变量，并且返回私有的工具对象 //我非要叫TimeTools，你咬我啊 1234567891011121314151617181920212223242526272829303132333435var TimeTools = &#123; abc: 123&#125;; (function() &#123; var pageOpenTime = new Date(); function getPageOpenTime() &#123; return pageOpenTime; &#125; function getNow() &#123; return new Date(); &#125; var TimeTools = &#123; getPageOpenTime: getPageOpenTime, getNow: getNow &#125;; var oldTimeTools = window.TimeTools; function noConflict() &#123; window.TimeTools = oldTimeTools; return TimeTools; &#125; TimeTools.noConflict = noConflict; window.TimeTools = TimeTools&#125;)();//测试代码(function() &#123; var TimeTools = window.TimeTools.noConflict(); console.log(TimeTools.getNow()); //我的API console.log(window.TimeTools.abc); //原始页面上的全局变量&#125;)(); 通过如上层层深入的设计，我们可以保持js代码的封闭性，在开发底层库或者中间件的过程中，可以大大降低冲突的风险，更便于调试。]]></content>
      <tags>
        <tag>开发面谈</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo模板标签测试案例]]></title>
    <url>%2FHexo%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[No arguments. Plain blockquote.：Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. Quote from a book：Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake Quote from Twitter：NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 Quote from an article on the web：Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing A plain code block：1alert(&apos;Hello World!&apos;); Specifying the language：1[rectangle setX: 10 y: 10 width: 20 height: 20]; Adding a caption to the code block：Array.map1array.map(callback[, thisArg]) Adding a caption and a URL：_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] To add pull quotes to your posts:content To embed a jsFiddle snippet: To embed a Gist snippet: To embed an iframe: Inserts an image with specified size： Inserts a link with target=”_blank” attribute：text url [external] [title] Inserts code snippets in source/downloads/code folder： Include links to other posts： Include post assets： If certain content is causing processing issues in your posts, wrap it with the raw tag to avoid rendering errors： content Use text placed before the tag as an excerpt for the post：Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 图像：]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
