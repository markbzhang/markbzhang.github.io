<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[未来世界的幸存者读后感]]></title>
    <url>%2F%E8%AF%BB%E5%90%8E%E6%84%9F%2F%E6%9C%AA%E6%9D%A5%E4%B8%96%E7%95%8C%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[感叹技术带给未来世界的冲击，也担忧未来世界变化的样子！ 技术带来的发展，冲击着很多岗位，特别是先从容易被复制和替换的低级工作岗位，比如汽车司机，银行柜员，物流快递人员 等，我在想，当地球上所有汽车都连成一个大的网络，实现无人驾驶，那司机，和快递人员，还有交通警察就会完全失业了！这个时间会出现在什么时候？ 你猜下！ 深切明白到这个世界上没有安全的工作岗位，终身学习？“终身学习”这个词完全没错，但是想通过“终身学习”保持职业竞争力，我觉得不太可能。人类社会的就业形态正在发生深刻的改变，“终生职业”越来越少了。每个人都应该尽早打算。 当你熟悉科技史以后，再看待历史的观点，再一次发生了巨大的变化。我现在认为，主导历史的因素，短期（一年到几年）是政治，中期（几年到几十年）是经济，长期（几十年到几百年）则是技术。 长期来看，政治和经济都不太重要，影响不了趋势，真正起决定性作用的是技术。政治和经济只能改变资源的分配和价格，只有技术才能创造出新东西。政治和经济只能使人类在平面上移动，只有技术才能使得人类向上提升，进入下一个阶段。从石器时代，铁器时代，四大发明，工业革命，蒸汽机等无一不是技术推进着社会的演变。一想到我的寿命只有几十年，我就感到特别难过。倒不是因为我害怕死亡，而是因为我将没有机会看到，未来一千年中各种新奇有趣的新技术。 未来，人类可能会分化为两个主要的等级：一个全新的更先进的精英阶级，很聪明，很富有，有更好的基因和更长的寿命；还有一个全新的一无用处的无产阶级，他们将越来越穷地等待死亡，可能变成没有工作、没有目标、整日靠吸毒度日、戴着VR头盔消磨时光的乌合之众。随着人工智能变得越来越聪明，会有更多的人被挤出就业市场。没人知道大学该学什么，因为没人知道20岁的时候学的东西到了40岁还有没有用。等你知道的时候，已经有数十亿人变得一点用都没有了。这不是偶然，而是必然。 大学课程是为了那些不知道学什么的人设计的，千万不要因为自己找不到方向，而被这些课程”画地为牢“限制住。你要主动去接触和学习，那些自己感兴趣的东西。引用一个网友的话，”你要做的就是自主、跨界、终身学习“。我后悔读了大学，更后悔没这样的觉悟！ 给自己的职业建议： 1.建议虽然很多人在选择职业时受到家庭、环境等方面因素的影响，不一定能从事自己非常感兴趣的工作，但是如果可能的话，一定要以兴趣为要。这样在工作时会很开心，在个人发展方面也会取得很好的成就。 因为只有兴趣才能使你乐在其中，乐在其中你才会产生热情，充满热情才能使你做到卓越。 2.认知认知影响态度，态度决定一切。 侯捷老师认为，一个人在选择发展道路时，尤其重要的是要对自己有一个正确的认知。每个人的兴趣可能会变，有些人看到某个行业有发展，有前途，因此对这个行业、这条路产生很大兴趣，这是非常可能的。但是每个人的本质基本不变，你是否甘于寂寞，是否能够与寂寞为伍？你的抗压性怎样？你的毅力强不强？你的心理素质如何？这些特质都是不易改变的，而且只有你自己才能给出这些问题的准确答案。只有对自己有了正确的认知后，才能决定往哪个方向发展。 他认为，做 IT 产业非常寂寞，也非常辛苦，大家可能在周末的晚上都要加班，这就要求从事该产业的人必须甘于寂寞，具备一定的忍耐力。侯捷先生在年轻的时候非常努力，曾被称为部门的“门神”，通常都是最早来，最晚走。他认为如果一个人喜欢交际应酬，喜欢公关，就应该尽早离开这个行业，因为选择道路一定要忠实于你的本质、你的兴趣。 我补充一点，软件工程师主要跟机器打交道，而不是跟人打交道。有时，你会整整一天坐在电脑屏幕前，不说一句话，全神贯注地调试软件。所以，如果你特别喜欢社交场合，喜欢跟人互动，你可能不适合当软件工程师。 3.EQ（情商）有能力读完大学的人，聪明才智基本上处于同一水平，没有人可以凭借聪明就可以取得成功。尤其是在进入社会后聪明才智已经退为次要位置，人们更重视 EQ 方面的东西，包括你的人际关系能力、沟通表达能力，抗压性、处理危机的能力等等。 4.学技术要掌握本质我们在学习技术时应该注意掌握技术的本质性、不变性和可复用性。本质的东西不易变，不易变就可复用，这三者是一体的。 在接触先进的技术时，如果我们能将它的底层结构 、本质性的东西搞清楚，会给我们带来莫大的帮助。本质性、结构性的东西属于基础建设方面的问题，它对我们做项目可能不会带来直接的帮助，但在无形中会带来很大的影响，无形的通常是最宝贵的！世界上没有万变不变的手法，只有万变不变的宗旨。 5.刻苦修炼内功学武的人都必须从最基本的马步、吐纳等内功方面学起，招术很重要，但如果没有内功方面的基础，招术也只能停留在基本的层面，不会到达很高的成就。 在技术追求方面也一样，我们有时候会太热心于学习业界的新技术，每一样都想沾一点。其实不必太急，基本功的东西更重要，研究得扎实一些，招术就比较容易创作了。 6.唯坚持得成功。坚持、毅力对一个人的成功是最重要的。有一句话说：在大树底下站久了，树阴就是你的。 侯捷老师自认才能平庸，但很能坚持。他的这个个性在朋友之间是被称道的。虽然有时坚持并不代表一定成功，但只有坚持才能有成功的机会。年轻时尽量刻苦一些，使肉体承受最大的痛苦，年龄稍大一些的时候才能享受成果。有一句话“退一步海阔天空”，但侯捷先生更希望大家“撑一下海阔天空”，一试再试做不成，再试一下。 7.不要别人点什么，就做什么尼古拉斯.泽卡斯的第一份工作，只干了8个月，那家公司就倒闭了。他问经理，接下来他该怎么办，经理说： ”小伙子，千万不要当一个被人点菜的厨师，别人点什么，你就烧什么。不要接受那样一份工作，别人下命令你该干什么，以及怎么干。你要去一个地方，那里的人肯定你对产品的想法，相信你的能力，放手让你去做。“ 他从此明白，单单实现一个产品是不够的，你还必须参与决定怎么实现。好的工程师并不仅仅服从命令，而且还给出反馈，帮助产品的拥有者改进它。 8.推销自己泽卡斯进入雅虎公司以后，经理有一天跟他谈话，觉得他还做得不够。 ”你工作得很好，代码看上去不错，很少出Bug。但是，问题是别人都没看到这一点。为了让其他人相信你，你必须首先让别人知道你做了什么。你需要推销自己，引起别人的注意。“ 他这才意识到，即使做出了很好的工作，别人都不知道，也没用。做一个角落里静静编码的工程师，并不可取。你的主管会支持你，但是他没法替你宣传。公司的其他人需要明白你的价值，最好的办法就是告诉别人你做了什么。一封简单的 Email：”嗨，我完成了 XXX，欢迎将你的想法告诉我“，就很管用。 9.学会带领团队工作几年后，已经没人怀疑泽卡斯的技术能力了，大家知道他能写出高质量的可靠代码。有一次，他问主管，怎么才能得到提升，主管说： ”当你的技术能力过关以后，就要考验你与他人相处的能力了。“ 于是，他看到了，自己缺乏的是领导能力，如何带领一个团队，有效地与其他人协同工作，取到更大的成果。 10.生活才是最重要的有一段时间，泽卡斯在雅虎公司很有挫折感，对公司的一些做法不认同，经常会对别人发火。他问一个同事，后者怎么能对这种事情保持平静，同事回答： ”你要想通，这一切并不重要。有人提交了烂代码，网站下线了，又怎么样？工作并不是你的整个生活。它们不是真正的问题，只是工作上的问题。真正重要的事情都发生在工作以外。我回到家，家里人正在等我，这才重要啊。“ 从此，他就把工作和生活分开了，只把它当作“工作问题”看待。这样一来，对工作就总能心平气和，与人交流也更顺利了。 11.自己找到道路泽卡斯被提升为主管以后，不知道该怎么做。他请教了上级，上级回答： ”以前都是我们告诉你做什么，从现在开始，你必须自己回答这个问题了，我期待你来告诉我，什么事情需要做。“ 很多工程师都没有完成这个转变，如果能够做到，可能就说明你成熟了，学会了取舍。你不可能把时间花在所有事情上面，必须找到一个重点。 12.把自己当成主人泽卡斯每天要开很多会，有些会议根本无话可说。他对一个朋友说，我不知道自己为什么要参加这个会，也没有什么可以贡献，朋友说： ”不要再去开这样的会了。你参加一个会，那是因为你参与了某件事。如果不确定自己为什么要在场，就停下来问。如果这件事不需要你，就离开。不要从头到尾都静静地参加一个会，要把自己当成负责人，大家会相信你的。“ 从那时起，他从没有一声不发地参加会议。他确保只参加那些需要他参加的会议。]]></content>
      <categories>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB开发面面谈之（5）——写JS时必须注意的的一些问题]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2FWEB%E5%BC%80%E5%8F%91%E9%9D%A2%E9%9D%A2%E8%B0%88%E4%B9%8B%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E5%86%99JS%E6%97%B6%E5%BF%85%E9%A1%BB%E6%B3%A8%E6%84%8F%E7%9A%84%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[下面例举了日常前段开发中遇到的场景，解决方案有很多，但从开发阶段就进行规范，可以很大程度避免很多后续的潜在和兼容问题。 获取body元素非标准做法 1document.body W3C规范方法 1document.getElementsByTagName(&apos;body&apos;).item(0) 使用jQuery/Zepto 1$(&apos;body&apos;); 获取窗口标题非标准做法 1document.title W3C规范方法 1document.getElementsByTagName(&apos;title&apos;).item(0).innerHTML 使用jQuery/Zepto 1$(&apos;title&apos;).text() 监听iframe的加载完成事件 写法1: 1iframe.onload = function() &#123;...&#125; 问题:存在兼容性问题，IE6、7无效 写法2: 1iframe.onload = iframe.onreadystatechange = function()&#123;...&#125; 问题:逻辑复杂，事件绑定逻辑混乱，在某些浏览器上onload和onreadystatechange都会触发，需要另外加标记位判断，逻辑复杂。 简洁而完全兼容的写法: 12345678var bindIframeOnloadEvent = function(el, onload) &#123; if (el.attachEvent)&#123; el.attachEvent(&quot;onload&quot;, onload); &#125; else &#123; el.onload = onload; &#125;&#125;;bindIframeOnloadEvent(iframe, function()&#123;...&#125;); 如何操作iframe内部的window 写法1: 1iframe.contentWindow 问题: 部分浏览器不兼容（IE6\7），获取失败 写法2: 1document.frames[frameId] 问题: 非标准调用，兼容性是问题，强制必须为iframe添加ID。 简洁而完全兼容的写法: 1234var getIframeWindow = function(el) &#123;return el.contentWindow || el.contentDocument.parentWindow;&#125;;var win = getIframeWindow(iframe); 设置iframe的边框 写法1: 1iframe.boder = 0; 问题: 非W3C标准，后面很可能废弃，部分浏览器不一定支持 写法2: 1iframe.style.boder = &apos;none&apos;; 问题: 完全依赖CSS控制，但存在兼容性问题，IE继续头疼 最终解决方案: 12iframe.boder = 0;iframe.style.boder = &apos;none&apos;; 如何在a标签上绑定鼠标点击事件 写法1: 1&lt;a href=&quot;javascript:func();&quot;&gt;test&lt;/a&gt; 问题: 不符合CSP规范 等价于全局eval。只能调用公开的全局方法，污染全局变量 鼠标悬停时，状态栏会显示要运行的代码？！这对最终用户不友好 运行代码的上下文是window对象，和事件处理模型相违背 写法2: 1&lt;a href=&quot;#&quot; onclick=&quot;func();&quot;&gt;test&lt;/a&gt; 问题: 不符合CSP规范 onclick和href在部分浏览器(IE继续躺枪)行文诡异，执行冲突异常 等价于全局eval。只能调用公开的全局方法，污染全局变量（原因同写法1） 写法3: 1&lt;a href=&quot;#&quot; onclick=&quot;func();return false;&quot;&gt;test&lt;/a&gt; 问题:只解决了问题2，其余问题仍存在 标准写法: 123456&lt;a id=&apos;aTest&apos;&gt;test&lt;/a&gt;&lt;script&gt;document.getElementById(&apos;aTest&apos;).onclick = function() &#123;func();&#125;;&lt;/script&gt; 使用jQuery/Zepto亦可，存在唯一的小问题是鼠标指针不是手形，是默认。可采用CSS样式来解决cursor:pointer 。 script标签的书写方法深挖要点 script标签的type属性不是必须的，默认缺省就是text/javascript script标签的language属性完全无用（asp时代微软似乎使用该属性来标记服务端语言是vb还是c#），不要画蛇添足 动态创建的script标签必须要指定type=’text/javascript’，否则JS不会执行 1234var script = document.createElement(&apos;script&apos;);script.type = &apos;text/javascript&apos;;script.src = &apos;###&apos;;document.getElementsByTagName(&apos;body&apos;).item(0).appendChild(script); 动态创建的script追加动作是异步的，并不会立刻取得script运行结果，如果要等待加载完成需要监听完成事件 使用非标准或者比较新的属性需要格外注意，不要使代码逻辑依赖于这些特性。如defer/async属性 使用script.onerror来监听脚本执行失败的情况（语法错误，初始化运行时错误等都会触发） 监听script的完成事件比较复杂。 1234567891011varbindScriptOnloadEvent = function(script, onload) &#123; var done = false; script.onload = script.onreadystatechange = function() &#123; if (!done &amp;&amp; (!this.readyState || this.readyState == &apos;loaded&apos; || this.readyState == &apos;complete&apos;)) &#123; done = true; script.onload = script.onreadystatechange = null; onload(); &#125; &#125;;&#125;;bindScriptOnloadEvent(script, function()&#123;...&#125;); 需要考虑兼容性，所以代码较多 substr函数不要使用原因：非标准，在部分浏览器报错，甚至连我的Android4.0上的浏览器都不认该函数 替代方案：使用substring函数。 jQuery/Zepto选择器的.text()和.html()方法现状：大多数开发同学会混淆两者并乱用，不清楚何时用哪个 详解：.text()方法用于获取和设置文本内容，.html()方法用户获取和设置HTML内容，当要设置或获取的内容仅仅为文本时，两者行为完全相同，但要操作的文本内容是HTML时，行为有着本质区别。 总结： 根据实际需要选择使用哪个方法，如能断定内容为纯文本请使用text()方法。仅当确实需要渲染HTML时才用html()方法 从安全角度，text()方法比html()方法更安全，无注入风险。 严格意义上，html()方法不符合CSP规范，直接将字符串解析为DOM节点 业务需要确实要使用.html()方法渲染动态内容时，必须做安全检查，避免恶意代码注入 .text()和.html()获取值可能存在代码缩进（空格和TAB），如有需要可以使用$.trim()来剔除 数组与对象深挖要点： 数组对象仅有concat/reverse/slice/splice为标准API，而且绝对完全兼容 数组对象请勿使用indexOf、lastIndexOf、map、every、forEach等非标准API，不仅兼容性存在问题，而且效率不一定高，反而不如自己实现 遍历数组请将.length缓存到变量 1for(vari=0,l=arr.length;i&lt;l;i++)&#123;...&#125; 遍历数组请勿使用此写法 1for(vari in arr)&#123;...&#125; 遍历key-value型对象必须使用hasOwnProperty()来过滤遍历结果。 1234for(var key in obj) &#123;if(!obj.hasOwnProperty(key) continue; //...&#125; 不论是数组或对象，在遍历操作时不要改变被遍历的变量结构，如增删元素，增删key值等（虽然你可以这么做）,对于元素自身及子成员的修改是绝对安全的。 关于Prototype的使用要点： 不要乱用Prototype。不要轻易在Object/Array/Function等对象上追加prototype（虽然我们已有某些库这么做了）容易产生歧义冲突，在使用for～in遍历时很容易引发问题。 自定义的prototype成员会在for～in循环中出现，请根据实际情况使用hasOwnProperty()来过滤遍历结果。 不严谨的写法： 12345678910111213141516function Test() &#123;&#125;Test.prototype.a = 1;Test.prototype.b = 2;var o = new Test();for(vari in o) &#123;console.log(&#123;key: i, value: o&#125;);&#125;//&#123;key:a, value:1&#125;//&#123;key:b, value:2&#125;严谨的写法：var o = new Test();for(vari in o) &#123;if(!o.hasOwnProperty(i)) continue;console.log(&#123;key: i, value: o&#125;);&#125;//无输出 对象的__proto成员，用途是获取当前实例的原型对象。非标准实现，存在兼容性问题，请不要使用 原则上不要轻易重写已存在的prototype方法。但可以在单个实例中覆写该方法 prototype上定义静态对象变量，会造成所有对象共用，而不是分别创建实例，请在构造方法中分配实例 错误写法： 12345678910111213141516171819function Test() &#123;&#125;Test.prototype.arr = [];var a = new Test();var b = new Test();a.arr.push(1);b.arr.push(2);console.log(a.arr, b.arr);//[1,2], [1,2]正确写法function Test() &#123;this.arr = [];&#125;var a = new Test();var b = new Test();a.arr.push(1);b.arr.push(2);console.log(a.arr, b.arr);//[1], [2] 总结JS是门灵活的语言，灵活到想怎么写都可以。但里面坑还是不少的。在有多种选择时，多考虑下哪种方法更好，而不是盲目选择一种。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>开发面谈</tag>
        <tag>面试</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB开发面试畅谈（3）——内容安全策略CSP]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2FWEB%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E7%95%85%E8%B0%88%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5CSP%2F</url>
    <content type="text"><![CDATA[什么是CSP？CSP是由单词 Content Security Policy 的首单词组成，CSP旨在减少(注意这里是减少而不是消灭)跨站脚本攻击。 CSP是一种由开发者定义的安全性政策性申明，通过CSP所约束的的规责指定可信的内容来源（这里的内容可以指脚本、图片、iframe、fton、style等等可能的远程的资源）。通过CSP协定，让WEB处于一个安全的运行环境中。 更多关于CSP的介绍可以参考W3C的相关文档： https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html#content-security-policy-header-field一部分中文翻译：CSP - HTML5 Chinese Interest Group Wiki CSP的讨论CSP的出现可以一定程度上的减少XSS的攻击，但不一定意味着XSS的消失。 很多人把它喻为XSS攻击的终结者，因为这种策略不再像传统只靠各种正则和特征匹配来识别跨站攻击Payload，而是直接从协议层把一些存在安全隐患的用法默认给干掉了，把同源同域更发挥到了极致。 只允许本站资源Content-Security-Policy： default-src‘self’ 允许本站的资源以及任意位置的图片以及http://trustedscripts.example.com下的脚本。Content-Security-Policy： default-src ‘self’；img-src *；script-src http://trustedscripts.example.com。 CSP策略在默认的情况下是不允许使用data URIs资源的,如果要使用，那么需要显示的指定,比如:img-src ‘self’ data: script-src：在处理脚本资源的时候设置”unsafe-inline”可以阻止内联Js代码的执行。使用unsafe-eval开关可以禁止eval,setTimeout,setInterval函数的执行。 object-src：控制embed,code,archive applet等对象。 style-src：会控制样式表@import和rel时所引入的URI资源，设置unsafe-inline规则可以是浏览器拒绝解析内部样式和内联样式定义。并不会阻止链入外部样式表。 img-src：可以控制图片资源的连接，包括img标签的src属性，以及CSS3中的url()和image()方法，以及link标签中的href属性(当rel设置成与图像相关的值，比如HTML支持的icon)。 media-src:控制媒体类型的外部链入资源，如video, audio, source, 和track标签的src属性。 frame-src:控制内嵌框架包含的外部页面连接：iframe or a frame。 font-src：控制CSS中的@font-face connect-src：控制XMLHttpRequest中的open()，WebSocket，EventSource inline script和eval类型函数(包括eval、setInterval、setTimeout和new Function())是不被执行的。另外data URIs也是默认不允许使用的，XBL,只允许通过chrome:和resource:形式uri请求的XBL,其它的比如在CSS中通过-moz-binding来指定的XBL则不允许被执行。 早期WEB开发的规范并不明确，为了向前兼容性，最新的浏览器仍兼容着最古老而且可能存在风险的语法和接口 。通俗的讲，CSP明确地告诉我们，哪些WEB开发行为对于宽松模式来说是可以使用的，但出于安全问题我们应尽早摒弃。我们不仅要做到实现更能，而且要更好更安全地实现。 下面例举个CSP适用的实际场景，大家会一目了然CSP的约束内容: 不执行Inline JavaScriptInline JavaScript和eval一样危险，将不会被执行。这条规则将同时禁止内嵌&lt; script &gt;块和内联事件（例如：&lt; button onclick=”…” &gt;;）。这条规则通过禁止第三方脚本避免大量的跨脚本攻击。同时它还强制您编写内容与表现分离的代码（这本就是您该做的，对吧？）。用个例子说明这一点：假设您在一个单独的popup.html文件中实现如下Browser Action弹出页： 123456789101112131415161718192021222324&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Awesome Popup!&lt;/title&gt;&lt;script&gt;function awesome() &#123; // do something awesome! &#125;functiontotallyAwesome() &#123; // do something TOTALLY awesome! &#125;functionclickHandler(element) &#123;setTimeout(&quot;awesome(); totallyAwesome()&quot;, 1000); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button onclick=&quot;clickHandler(this)&quot;&gt; Click for awesomeness!&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 为了使它能以您所希望的方式运行，结合本规则，需要做以下三个方面的修改： clickHandler的定义需移到外部JavaScript文件中（如：popup.js）。 内联事件需通过addEventListener，并移到外部popup.js文件中实现。 为了避免使用转换字符串到JavaScript的函数”awesome(); totallyAwesome()”的执行，setTimeout调用需要重写。 修改之后将会像下面这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445popup.js:function awesome() &#123; // Do something awesome! &#125;functiontotallyAwesome() &#123; // do something TOTALLY awesome! &#125;functionawesomeTask() &#123;awesome();totallyAwesome(); &#125; functionclickHandler(e) &#123;setTimeout(awesomeTask, 1000); &#125; // Add event listeners once the DOM has fully loaded by listening for the // `DOMContentLoaded` event on the document, and adding your listeners to // specific elements when it triggers.document.addEventListener(&apos;DOMContentLoaded&apos;, function () &#123;document.querySelector(&apos;button&apos;).addEventListener(&apos;click&apos;, clickHandler); &#125;); popup.html:&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Awesome Popup!&lt;/title&gt;&lt;script src=&quot;popup.js&quot;&gt;&lt;/script&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;Click for awesomeness!&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 综述首先CSP是可以在一定程度上提高XSS的攻击难度的，甚至杜绝XSS，前提是CSP策略用的好。还要考虑CSP能否普及，因为CSP在提供安全性的同时也提高了前端逻辑的复杂度，很多资源需要调整，类似QQ，新浪，搜狐这样的站群，想通过合适的CSP同时提高安全性和易用性是很难的。但是我们仍要尽可能使用更加规范的编码方式提高WEB开发的质量。 目前CSP规范并未应用于全部浏览器，仅仅新浏览器会得到支持。但是遵循CSP规范开发的WEB应用将获得更好的代码结构和用户体验，大大提高安全性。这可能会彻底改变你之前的开发习惯和方式。甚至你会恍然发现，之前的代码是如此脆弱不堪。甚至会有些不适。但是，时代总是向前发展的。当你渐渐习惯并接受了它，才发现它带来的无尽好处，助你在web开发的道路上走得更快更好。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>开发面谈</tag>
        <tag>面试</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB开发面试畅谈（2）——多场景下的图片优化策略]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2FWEB%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E7%95%85%E8%B0%88%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E5%A4%9A%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[常规策略能不用图片就不用，透明、边框、圆角、阴影、渐变都可以用CSS实现，SVG、canvas或iconfont等在主流浏览器中都已经普遍支持，可代替图片，且体积更小更具优势。SVG可无失真无限放大缩小；Canvas可实现2D、3D动态效果等。 压缩 简单压缩。使用在线图片压缩网站，使用构建工具，grunt(grunt-imagemin)、gulp(gulp-book)、webpack(url-loader)等。 CDN部署 &amp; 合理缓存设置 &amp; 多尺寸支持 CDN部署不用多说，几乎是任何图片服务的标配，要求支持 gzip 压缩。针对不同的图片类型设置不同的浏览器缓存时间（max-age），包括：用户头像、Logo、icon、文案配图等；针对不同的设备尺寸，采用不同尺寸的图片大小（PC、Mobile、Pad）；针对不同的设计稿图片尺寸需求，拉取不同的图片尺寸（用户头像采用100像素，新闻类列表页可采用400像素，详情页拉取1000像素），可节省流量、缩短请求传输时间。 使用Data-url/base64 在http1.x时代，为了减少小图片请求带来的损耗（主要是协议头）而将其转化为Base64编码内嵌在CSS或者HTML中。存在的问题是转换为Base64编码的体积要比原图本身大。通常我们只将小于8kb的图片转换为Base64。 合并精灵图 使用构建工具将多个小图合并在一张大图上，特点是减少HTTP请求数。缺点是：“一荣俱荣，一损俱损”。一旦加载失败，所有图片都会展示失败。 接入webP、sharpP等优秀图片格式，减少带宽流量，加快图片加载速度 渐进增强 图片加载有逐行扫描和交错扫描，在弱网络环境下，使用交错扫描加载方式的大图会先让用户看到图片的大致轮廓，对用户更加友好。具体可在Photoshop图片导出中选择交错体验尝试。 渐进增强其他方式 知名博客发布网站Medium中的图片采用了 纯色 -&gt; 低质量拉伸图片+高斯模糊 -&gt; 正常标准图片的加载过程。可以通过分析其代码发现，其原理是这样的：1）渲染一个div，通过对容器设置宽高使其比例和大小与最终图片的比例和大小相同，避免图片加载出来的时候导致的页面的重排；2）使用 img 标签来加载一张原图质量的 10% ~ 20%的小图。由于体积小，所以可以很快加载并显示；3）小图加载完成后使用 canvas 绘制高斯模糊透明效果覆盖在小图之上。同时请求最终要加载的大图；4）最终大图加载完成后隐藏canvas。缺点：费流量，适合WiFi和有线网络。实现稍微复杂 按需加载 懒加载：需要的时候才去加载，不需要不加载。 预加载：对于即将看到的图片预拉取，比如图片查看器中，预先拉取当前图片中后2~3张。1234567891011常见的方式如：// 长列表if(document.documentElement.clientHeight &gt; targetElement.getBoundingClientReact().top)&#123; // load image&#125;// 图片查看器const PRELOADNUM = 3if(index &lt;= current + PRELOADNUM &amp;&amp; index &gt;= current - PRELOADNUM)&#123; // load image&#125; 请求失败占位图 &amp; 重试机制 图片加载失败后需要有占位图（纯色/图片），并且有稍后自动重试的功能。1234567891011121314151617//部分代码state=&#123; src: http://image.xxx.com/12345.png, retry: 0&#125;render() &#123; return &lt;img onError=&#123;this.onError.bind(this)&#125; src=&#123;src&#125; /&gt;&#125;onError(e, src)&#123; if(this.state.retry &gt; 0) &#123; // 仅重试一次，否则加载默认图 this.setState(&#123; src: http://image.xxx.com/defaultImg.png &#125;) &#125;else &#123; let &#123; src. retry &#125; = this.state, src += &apos;&amp;time=&apos; + ~~(Math.random()*1E6); this.setState(&#123; src, retry： ++retry &#125;); &#125;&#125; 媒体查询 &amp; picture 标签 实验性功能详见HTML picture元素 活动页活动H5页面的特点是具有高并发访问量。尤其是在节假日访问量飙涨的状况下，对访问量的预估对于图片优化具有非常重大的意义。我们应该怎样优化？ 活动页面从设计上就应该避免大量的图片展示，尽可能减少图片 使用一张背景大图，避免多个图片使用绝对定位层叠 如果有可能，最好使用CSS、SVG、canvas或iconfont代替图片； 减少图片请求数，小图片采用base64内嵌在CSS中； 采用离线包]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>开发面谈</tag>
        <tag>面试</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB开发面试畅谈（1）——Javascript封闭性设计]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2FWEB%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E7%95%85%E8%B0%88%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94Javascript%E5%B0%81%E9%97%AD%E6%80%A7%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[日常开发中，我们经常会提到模块化开发、代码规范等等，但到了以HTML和Javascript为首的WEB开发这里，一切都变了。 无论是HTML还是Javascript都以其松散的结构和宽松的规范极大降低了开发成本，但又同时引入了新的问题：不同的开发人员有着不同的开发习惯，当然这些习惯也有好有坏，大多数程序员只是坚持着”能运行就可以“的思想观念，而这些并不利于项目的长期发展。于WEB开发中松散的特性，许多思路和经验并不是语言层面约束的，而是通过特有的代码逻辑和结构加以维护。所以在观看下文时，请勿在评论中发表类似如下的评论：”搞那么复杂干嘛？直接var一个变量去改不就好了，干嘛用闭包，我自己写的代码自己清楚，我用人格担保我的调用正确“，扯远了，如果你认同我上面的大体思想，请继续往下看。 大多数开发人员在第一次开发WEB时，一定写过类似如下的代码:123var a = 1;var b = 2;alert(a+b); 我们欢呼着把脚步踏入了JS开发行列，并且意识到JS的强大，简单堆叠代码就能实现功能。但时到如今回头看这段代码，确实问题重重。提到此，我们已经不是关注功能实现的问题，而是设计的问题。功能是个人都能实现，但设计确实良莠不齐因人而异。以上述代码为例，我们仅仅需要实现alert(a+b)却同时生硬的在全局书写了两个全局变量a、b。而在其余地方这两个变量均无用。倘若另一段代码也没做封闭处理，也用全局a、b，很容易引发冲突问题，而且不是异常，难于定位。实现封闭，最简单的方式是定义闭包，闭包简而言之就是构造一个匿名函数并且立刻执行它。我们会得到执行结果，却不会将局部变量暴露给外层或全局。 优化后的代码12345(function() &#123; var a = 1; var b = 2; alert(a+b);&#125;)(); 简单构造的闭包语法，可以很方便地将非闭包语法加以封闭，在调试阶段，确保变量不冲突的前提下，可将首尾行注释，方便在Chrome等开发工具中调试12345//(function() &#123; var a = 1; var b = 2; alert(a+b);//&#125;)(); 封闭性是一个良好代码设计的开始，闭包内的变量默认是私有（这里不考虑不用var声明的全局变量，参照JS代码规范）。我们可以选择性地在闭包的结尾将公开成员公开出去。1234567(function() &#123; var pageOpenTime = new Date(); function getPageOpenTime() &#123; return pageOpenTime; &#125; window.getPageOpenTime = getPageOpenTime;&#125;)(); 但也不是教条主义。比如我们要定义一组API，其实可以这么实现但按照前面的规范，getNow()与getPageOpenTime()是互相独立的，而且getNow()中理应无法调用pageOpenTime。代码该写成这样：1234567891011121314(function() &#123; var pageOpenTime = new Date(); function getPageOpenTime() &#123; return pageOpenTime; &#125; window.getPageOpenTime = getPageOpenTime;&#125;)();(function()&#123; function getNow() &#123; return new Date(); &#125; window.getNow = getNow;&#125;)(); 那么恭喜你，你已经犯了教条主义。也就是过度设计。我们实现的API内部是几乎不可能被外界干预的。没必要设过于复杂的限制约束，不论复杂度还是维护都麻烦。这又是与封闭性互为反面的，如何权衡呢？我们只需要保证对外公开的接口严格准确，内部是可以更灵活一些的。即便丧失了局部封闭性，但对外接口还是封闭的。而且也更加灵活。 那么我们最终实现的代码如下即可。1234567891011(function() &#123; var pageOpenTime = new Date(); function getPageOpenTime() &#123; return pageOpenTime; &#125; function getNow() &#123; return new Date(); &#125; window.getPageOpenTime = getPageOpenTime; window.getNow = getNow;&#125;)(); 再深入思考一下，我们把一坨函数直接暴露给window真的好么？倘若我们有100个函数，不敢想象。。我们需要做一个包装对象1234567891011121314(function() &#123; var pageOpenTime = new Date(); function getPageOpenTime() &#123; return pageOpenTime; &#125; function getNow() &#123; return new Date(); &#125; var TimeTools = &#123; getPageOpenTime: getPageOpenTime, getNow: getNow &#125;; window.TimeTools = TimeTools&#125;)(); 这样就保证全局只有唯一一个暴露对象了。 那我们继续深入，万一有另外一个人也蛋疼的起了个叫TimeTools的全局变量，咋办？？？继续冲突中我想说，非要把人往死路逼么？好吧，那我也拿出看家本领。参见jQuery.noConflict()方法大意就是在赋值全局变量时，先保存之前版本的全局变量，如果冲突，可以调用noConflict()方法回滚全局变量，并且返回私有的工具对象 //我非要叫TimeTools，你咬我啊 1234567891011121314151617181920212223242526272829303132333435var TimeTools = &#123; abc: 123&#125;; (function() &#123; var pageOpenTime = new Date(); function getPageOpenTime() &#123; return pageOpenTime; &#125; function getNow() &#123; return new Date(); &#125; var TimeTools = &#123; getPageOpenTime: getPageOpenTime, getNow: getNow &#125;; var oldTimeTools = window.TimeTools; function noConflict() &#123; window.TimeTools = oldTimeTools; return TimeTools; &#125; TimeTools.noConflict = noConflict; window.TimeTools = TimeTools&#125;)();//测试代码(function() &#123; var TimeTools = window.TimeTools.noConflict(); console.log(TimeTools.getNow()); //我的API console.log(window.TimeTools.abc); //原始页面上的全局变量&#125;)(); 通过如上层层深入的设计，我们可以保持js代码的封闭性，在开发底层库或者中间件的过程中，可以大大降低冲突的风险，更便于调试。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>开发面谈</tag>
        <tag>面试</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈ES6前后的异步编程]]></title>
    <url>%2FJavascript%2F%E8%B0%88%E8%B0%88ES6%E5%89%8D%E5%90%8E%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。 为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）两种模式概念很好理解。 ES6 诞生以前，异步编程的方法，大概有下面四种：回调函数 ，事件监听 ，发布/订阅 ，Promise对象。 回调函数这是异步编程最基本的方法。 假定有两个函数f1和f2，后者等待前者的执行结果。 12 f1(); f2(); 如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。 123456 function f1(callback)&#123; setTimeout(function () &#123; // f1的任务代码 callback(); &#125;, 1000); &#125; 执行代码就变成下面这样： 1f1(f2); 采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。 回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。 事件监听另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。 1f1.on(&apos;done&apos;, f2); 上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写： 123456 function f1()&#123; setTimeout(function () &#123; // f1的任务代码 f1.trigger(&apos;done&apos;); &#125;, 1000); &#125; f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 发布/订阅上一节的”事件”，完全可以理解成”信号”。 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。 这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件。 首先，f2向”信号中心”jQuery订阅”done”信号。 1jQuery.subscribe(&quot;done&quot;, f2); 然后，f1进行如下改写： 123456 function f1()&#123; setTimeout(function () &#123; // f1的任务代码 jQuery.publish(&quot;done&quot;); &#125;, 1000); &#125; jQuery.publish(“done”)的意思是，f1执行完成后，向”信号中心”jQuery发布”done”信号，从而引发f2的执行。 此外，f2完成执行后，也可以取消订阅（unsubscribe）。 1jQuery.unsubscribe(&quot;done&quot;, f2); 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 Promises对象Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。 简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成： 1f1().then(f2); f1要进行如下改写（这里使用的是jQuery的实现）： 12345678 function f1()&#123; var dfd = $.Deferred(); setTimeout(function () &#123; // f1的任务代码 dfd.resolve(); &#125;, 500); return dfd.promise; &#125; 这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。 比如，指定多个回调函数： 1f1().then(f2).then(f3); 再比如，指定发生错误时的回调函数： 1f1().then(f2).fail(f3); 而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是编写和理解，都相对比较难。 ES6诞生后，出现了Generator函数，它将 JavaScript 异步编程带入了一个全新的阶段。ES6也将Promise 其写进了语言标准，统一了用法，原生提供了Promise对象。 故ES6异步编程的方法，大概有两种：Generator函数，Promise。 Generator函数特点： 带星号function，yield语句 ，next() 获取下一个yield表达式中yield后的值，拥有遍历器接口，与for..of可搭配使用 下面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。这段代码非常像同步操作，除了加上了yield命令 12345678910111213141516var fetch = require(&apos;node-fetch&apos;);function * gen() &#123; var url = &apos;http://api.github.com/users/github&apos;; var result = yield fetch(url); console.log(result.bio);&#125;var g = gen();var result = g.next();result.value.then(function(data) &#123; return data.json();&#125;).then(function (data) &#123; g.next(data);&#125;); 执行过程: 首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。 缺点： 可以看到，虽然Generator函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段），即如何实现自动化的流程管理。 补充拓展 可以参考阮一峰的ECMAScript 6 入门用Thunk函数实现自动化流程管理,对Generator函数进行拓展，前提是每一个异步操作，都要是Thunk函数,进价就是再用CO模块来实现自动化流程管理，co模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co。后面，ES2017标准引入了async函数，对Generator再“语法升级”， async 函数是什么？一句话，它就是 Generator 函数的语法糖。async函数对 Generator 函数进行了改进，体现在以下四点： 内置执行器。 Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 更好的语义。 async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 更广的适用性。 co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 返回值是 Promise。 async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 PromiseES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 Promise 的基本用法就谈到这，更深入用法，请参考阮一峰的ECMAScript 6 入门 特别需要指出的是在ES6之前，promise是一套规范和原则，只要设计的库复合规范的要求就都可以算是promise, 目前比较流行的promise库（插件）有q和when，RSVP.js，jQuery的Deferred等。ES6后，将Promise 众多规范中的一种写入语言标准，ES6中的 Promise 是其中一种，各个 Promise 规范之间有细微的差别(主要是特性上的) 参考来源： ECMAScript 6 入门 Javascript异步编程的4种方法]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript跨域]]></title>
    <url>%2FJavascript%2Fjavascript%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[最近在项目开发的过程中遇到一些Javascript 跨域请求的问题，今天抽空对其进行总结一下，以备后用，也希望同学们在遇到类似问题的时候可以有所帮助。 Javascript跨域问题是web开发人员最常碰到的一个问题之一。所谓Javascript跨域问题，是指在一个域下的页面中通过js访问另一个不同域下的数据对象，出于安全性考虑，几乎所有浏览器都不允许这种跨域访问，这就导致在一些ajax和iframe应用中，使用跨域的web service会成为一个问题。 javascript跨域图表那到底什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表： 特别注意两点： 第一，如果是协议和端口造成的跨域问题“前台”是无能为力的， 第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。 “URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”（本段来自网络，个人觉得这段对js跨域描述得在清晰不过了）。 跨域请求无处不在，平时我们在开发活动过程中，活动静态页面通过Javascript访问前端CGI就是明显的主域相同，子域不同的跨域例子，一般活动静态页面都是类似这样的(http://业务名.xx.com/act/活动目录/xxx.html)，前端CGI 是这样的(http://www.xx.com/act/活动目录/xxx.cgi), 下面来看看我们都是如何处理跨域请求的： 动态创建script虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，script标签的src属性引用指向接收方的一个处理地址（后台），该地址返回的javascript方法会被执行，另外URL中可以传入一些参数，该方法只支持GET方式提交参数。我们常用FloadJS方法用的就是这种跨域方式。 使用Jquery中getScript和getJson方法实现跨域Jquery 的getScript 和 getJson方法都可以调用跨域的js或服务端脚本，但是它们的实现原理不一样。 getScript 方法语法：jQuery.getScript(url,success(response,status))该函数是简写的 Ajax 函数，等价于： $.ajax({ Type: get, url: url, dataType: “script”, success: success });jQuery 1.2 版本之前，getScript 只能调用同域 JS 文件。 1.2中，您可以跨域调用 JavaScript 文件。注意：Safari 2 或更早的版本不能在全局作用域中同步执行脚本。如果通过 getScript 加入脚本，请加入延时函数。 实现跨域的原理：通过 GET 方式请求载入并执行一个 JavaScript 文件， 相当于通过src的形式的导入一个外部的js getJson方法语法：jQuery.getJSON(url,data,success(data,status,xhr))该函数是简写的 Ajax 函数，等价于： $.ajax({ url: url, data: data, success: callback, dataType: json });在 jQuery 1.2 中，您可以通过使用 JSONP 形式的回调函数来加载其他网域的 JSON 数据，如 “myurl?callback=?”。jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。实现跨域的原理：采用Jsonp原理实现跨域到这里大家有没有发现一个问题，好像一直都在讨论http get 请求方式的跨域问题，难道post 请求就不存在跨域问题吗？其实原生态From 表单 POST 到一个后台处理脚本是不存在跨域问题，因为提交过程不牵涉到JS操作其它域名的对象，可是POST表单后，页面会刷新，给用户带来的体验不佳，这时我们经常会想到用jquery ajax post 方法来提交表单， 虽然这种方式不会刷新页面，但是会存在跨域问题。因为ajax本身实际上是通过XMLHttpRequest对象来进行数据的交互，而浏览器出于安全考虑，是不允许js代码进行跨域操作，进而会发警告，所以jquery ajax post 是行不通的，可能这时有人会说，用jsonp数据类型啊，但是jsonp目前只支持get请求方式，对post请求不支持。我们在平时开发过程又不得不用post方式，因为get方式对请求的数量有大小限制，那在这种情况下如何保证用户良好的页面体验，又能解决跨域问题呢? 其实这时我们可以用最常见的document.domain + iframe 方式来实现。 document.domain + iframe这种方式只适用主域名相同，子域名不同的情形，在我们项目开发过程，这种方式还是比较适用。 服务端代理从上面的说明可以看到，客户端的解决方案局存在一定的局限性，而且对于ajax跨域请求，无论两个域是否属于同个基础域，都无法在客户端加以解决，也就是说如果我们要想在ajax请求中访问其他域下的数据，就只能通过服务端进行处理了。服务端的解决方案的基本原理就是，由客户端将请求发给本域服务器，再由本域服务器的代理来请求数据并将响应返回给客户端。 使用HTML 5 postMessage方式HTML5中最酷的新功能之一就是 跨文档消息传输Cross Document Messaging。下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。otherWindow.postMessage(message, targetOrigin);otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。message: 所要发送的数据，string类型。targetOrigin: 用于限制otherWindow，“*”表示不作限制a.com/index.html中的代码。但是HTML5 在IE6, IE7浏览器下不兼容，目前移动端解决跨域问题用得比较多， PC机上用得比较少。 使用flash如果你要读取一个外部文件，比如swf，picture，mp3等等，那么就需要一个跨域策略文件,allow-access-from domain表示允许访问的URl，如果有多个依次添加，如果允许所有就一个 allow-access-from domain = “*”就可以了。 个人小结在项目开发过程如果能用get方式解决的就尽量使用它，毕竟get的性能也比post高，而且处理get跨域请求的方法也比较多，比如用jquery库的 getScript和getJson方法。如果提交的数据比较大，一定用post方式提交，并且考虑用户的功能体验，可以用document.domain + iframe的方式来处理。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 切合业务精用语句收集]]></title>
    <url>%2FMysql%2Fmysql%20%E5%88%87%E5%90%88%E4%B8%9A%E5%8A%A1%E7%B2%BE%E7%94%A8%E8%AF%AD%E5%8F%A5%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[同一个表，group by 对不同字段进行不同条件统计例如下面的 根据 self_wechatid 进行group by ，统计出 性别总数，男总数(gender = 1为男)，女总数(gender = 2为男)，不详总数。1234567891011121314151617181920212223242526272829303132SELECT self_wechatid, count(*) AS total, sum(IF(gender = 1, 1, 0)) AS man, sum(IF(gender = 2, 1, 0)) AS girl, ( count(*) - sum(IF(gender = 1, 1, 0)) - sum(IF(gender = 2, 1, 0)) ) AS nonFROM al_wx_contactWHERE create_time &gt; 1526730791GROUP BY self_wechatid; /*延伸拓展*/SELECT b.uid, u.username, count(*) AS total, sum(IF(c.gender = 1, 1, 0)) AS man, sum(IF(c.gender = 2, 1, 0)) AS girl, ( count(*) - sum(IF(c.gender = 1, 1, 0)) - sum(IF(c.gender = 2, 1, 0)) ) AS nonFROM al_wx_contact c left join al_wx_weixin_base b on c.self_wechatid = b.self_wechatid left join al_users u on b.uid = u.uidWHERE c.create_time &gt; 0GROUP BY b.uidORDER BY total desc; 同一张表中复制（有主键）1insert into 表1(字段1,字段2,字段3) select 字段1,字段2,字段3 from 表1 where id=1 连表（含where条件）更新Update语句123update sumholdtime s,province b set s.province = b.province where s.area_code=b.area_code;update t_tc_telephone s,t_mobile_number_section b set s.province=b.province,s.city=b.city where s.area_code = b.area_code and s.area_code != &apos;&apos;;update t_non_tc_telephone s,t_mobile_number_section b set s.province=b.province,s.city=b.city where s.area_code = b.area_code and s.area_code != &apos;&apos;; 从数据表t1 中把那些id值在数据表t2 里有匹配的记录全删除掉123DELETE t1 FROM t1,t2 WHERE t1.id=t2.id 或DELETE FROM t1 USING t1,t2 WHERE t1.id=t2.id 从数据表t1里在数据表t2里没有匹配的记录查找出来并删除掉123DELETE t1 FROM t1 LEFT JOIN T2 ON t1.id=t2.id WHERE t2.id IS NULL 或DELETE FROM t1,USING t1 LEFT JOIN T2 ON t1.id=t2.id WHERE t2.id IS NULL 从两个表中找出相同记录的数据并把两个表中的数据都删除掉1DELETE t1,t2 FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t1.id=25 注意此处的delete t1,t2 from 中的t1,t2不能是别名如：1delete t1,t2 from table_name as t1 left join table2_name as t2 on t1.id=t2.id where table_name.id=25 在数据里面执行是错误的（MYSQL 版本不小于5.0在5.0中是可以的） 后续持续更新中]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[透过迷你vue库，了解vue背后思想]]></title>
    <url>%2FJavascript%2F%E9%80%8F%E8%BF%87%E8%BF%B7%E4%BD%A0vue%E5%BA%93%EF%BC%8C%E4%BA%86%E8%A7%A3vue%E8%83%8C%E5%90%8E%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370/** * the super tiny vue.js. 简介：一个迷你vue库，虽然小但功能全面，可以作为想了解vue背后思想以及想学习vue源码而又不知如何入手的入门学习资料。 特性： * 数据响应式更新 * 指令模板 * MVVM * 轻量级 ## 功能解读 &lt;templete&gt; &lt;div id=&apos;app&apos;&gt; &lt;div&gt; &lt;input v-model=&apos;counter&apos; /&gt; &lt;button v-on-click=&apos;add&apos;&gt;add&lt;/button&gt; &lt;p v-text=&apos;counter&apos;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/templete&gt; &lt;script&gt;var vm = new Vue(&#123; id: &apos;counter&apos;, data: &#123; counter: 1 &#125;, methods: &#123; add: function () &#123; this.counter += 1; &#125; &#125; &#125;) &lt;/script&gt; 如上为一段模板以及js脚本，我们所要实现的目标就是将 vm 实例与id为app的DOM节点关联起来，当更改vm data 的counter属性的时候， input的值和p标签的文本会响应式的改变，method中的add方法则和button的click事件绑定。 简单的说就是, 当点击button按钮的时候，触发button的点击事件回调函数add,在add方法中使counter加1，counter变化后模板中的input 和p标签会自动更新。vm与模板之间是如何关联的则是通过 v-model、v-on-click、v-text这样的指令声明的。 ### 实现思路详解 * 查找含指令的节点 * 对查找所得的节点进行指令解析、指令所对应的实现与节点绑定、 节点指令值所对应的data属性与前一步关联的指令实现绑定、data属性值通过setter通知关联的指令进行更新操作 * 含指令的每一个节点单独执行第二步 * 绑定操作完成后，初始化vm实例属性值#### 指令节点查找 首先来看第一步，含指令节点的查找，因为指令声明是以属性的形式，所以可以通过属性选择器来进行查找，如下所示： `&lt;input v-model=&apos;counter&apos; type=&apos;text&apos; /&gt;` 则可通过 querySelectorAll(&apos;[v-model]&apos;) 查找即可。 root = this.$el = document.getElementById(opts.el), els = this.$els = root.querySelectorAll(getDirSelectors(Directives)) root对于根节点，els对应于模板内含指令的节点。 #### 指令解析，绑定 * 1.指令解析 同样以`&lt;input v-model=&apos;counter&apos; type=&apos;text&apos; /&gt;`为例，解析即得到 var directive = &#123; name: &apos;v-model&apos;, value: &apos;counter&apos; &#125; name对应指令名，value对应指令值。 * 2.指令对应实现与当前节点的绑定(bindDirective) 指令实现可简单分为函数或是包含update函数的对象，如下便是`v-text`指令的实现代码： text: function (el, value) &#123; el.textContent = value || &apos;&apos;; &#125; 指令与节点的绑定即将该函数与节点绑定起来，即该函数负责该节点的更新操作，`v-text`的功能是更新文本值，所以如上所示 更改节点的textContent属性值。 * 3. 响应式数据与节点的绑定(bindAccessors) 响应式数据这里拆分为 data 和 methods 对象，分别用来存储数据值和方法。 var vm = new Vue(&#123; id: &apos;counter&apos;, data: &#123; counter: 1 &#125;, methods: &#123; add: function () &#123; this.counter += 1; &#125; &#125; &#125;) 我们上面解析得到 v-model 对于的指令值为 counter,所以这里将data中的counter与当前节点绑定。 通过2、3两步实现了类型与 textDirective-&gt;el&lt;-data.counter 的关联，当data.counter发生set(具体查看defineProperty set 用法)操作时， data.counter得知自己被改变了，所以通知el元素需要进行更新操作，el则使用与其关联的指令(textDirective)对自身进行更新操作，从而实现了数据的 响应式。 * textDirective * el * data.counter 这三个是绑定的主体，数据发生更改，通知节点需要更新，节点通过指令更新自己。 * 4.其它相关操作 */var prefix = &apos;v&apos;; /** * Directives */var Directives = &#123; /** * 对应于 v-text 指令 */ text: function (el, value) &#123; el.textContent = value || &apos;&apos;; &#125;, show: function (el, value) &#123; el.style.display = value ? &apos;&apos; : &apos;none&apos;; &#125;, /** * 对应于 v-model 指令 */ model: function (el, value, dirAgr, dir, vm, key) &#123; let eventName = &apos;keyup&apos;; el.value = value || &apos;&apos;; /** * 事件绑定控制 */ if (el.handlers &amp;&amp; el.handlers[eventName]) &#123; el.removeEventListener(eventName, el.handlers[eventName]); &#125; else &#123; el.handlers = &#123;&#125;; &#125; el.handlers[eventName] = function (e) &#123; vm[key] = e.target.value; &#125; el.addEventListener(eventName, el.handlers[eventName]); &#125;, on: &#123; update: function (el, handler, eventName, directive) &#123; if (!directive.handlers) &#123; directive.handlers = &#123;&#125; &#125; var handlers = directive.handlers; if (handlers[eventName]) &#123; //绑定新的事件前移除原绑定的事件函数 el.removeEventListener(eventName, handlers[eventName]); &#125; //绑定新的事件函数 if (handler) &#123; handler = handler.bind(el); el.addEventListener(eventName, handler); handlers[eventName] = handler; &#125; &#125; &#125;&#125;/** * MiniVue */function TinyVue (opts) &#123; /** * root/this.$el: 根节点 * els: 指令节点 * bindings: 指令与data关联的桥梁 */ var self = this, root = this.$el = document.getElementById(opts.el), els = this.$els = root.querySelectorAll(getDirSelectors(Directives)), bindings = &#123;&#125;; this._bindings = bindings; /** * 指令处理 */ [].forEach.call(els, processNode); processNode(root); /** * vm响应式数据初始化 */ let _data = extend(opts.data, opts.methods); for (var key in bindings) &#123; if (bindings.hasOwnProperty(key)) &#123; self[key] = _data[key]; &#125; &#125; function processNode (el) &#123; getAttributes(el.attributes).forEach(function (attr) &#123; var directive = parseDirective(attr); if (directive) &#123; bindDirective(self, el, bindings, directive); &#125; &#125;) &#125; /** * ready */ if (opts.ready &amp;&amp; typeof opts.ready == &apos;function&apos;) &#123; this.ready = opts.ready; this.ready(); &#125;&#125;/************************************************************** * @privete * helper methods *//** * 获取节点属性 * &apos;v-text&apos;=&apos;counter&apos; =&gt; &#123;name: v-text, value: &apos;counter&apos;&#125; */function getAttributes (attributes) &#123; return [].map.call(attributes, function (attr) &#123; return &#123; name: attr.name, value: attr.value &#125; &#125;)&#125;/** * 返回指令选择器，便于指令节点的查找 */function getDirSelectors (directives) &#123; /** * 支持的事件指令 */ let eventArr = [&apos;click&apos;, &apos;change&apos;, &apos;blur&apos;]; return Object.keys(directives).map(function (directive) &#123; /** * text =&gt; &apos;v-text&apos; */ return &apos;[&apos; + prefix + &apos;-&apos; + directive + &apos;]&apos;; &#125;).join() + &apos;,&apos; + eventArr.map(function (eventName) &#123; return &apos;[&apos; + prefix + &apos;-on-&apos; + eventName + &apos;]&apos;; &#125;).join();&#125;/** * 节点指令绑定 */function bindDirective (vm, el, bindings, directive) &#123; //从节点属性中移除指令声明 el.removeAttribute(directive.attr.name); /** * v-text=&apos;counter&apos; * v-model=&apos;counter&apos; * data = &#123; counter: 1 &#125; * 这里的 counter 即指令的 key */ var key = directive.key, binding = bindings[key]; if (!binding) &#123; /** * value 即 counter 对应的值 * directives 即 key 所绑定的相关指令 如： bindings[&apos;counter&apos;] = &#123; value: 1, directives: [textDirective, modelDirective] &#125; */ bindings[key] = binding = &#123; value: &apos;&apos;, directives: [] &#125; &#125; directive.el = el; binding.directives.push(directive); //避免重复定义 if (!vm.hasOwnProperty(key)) &#123; /** * get/set 操作绑定 */ bindAccessors(vm, key, binding); &#125;&#125;/** * get/set 绑定指令更新操作 */function bindAccessors (vm, key, binding) &#123; Object.defineProperty(vm, key, &#123; get: function () &#123; return binding.value; &#125;, set: function (value) &#123; binding.value = value; binding.directives.forEach(function (directive) &#123; directive.update( directive.el, value, directive.argument, directive, vm, key ) &#125;) &#125; &#125;)&#125;function parseDirective (attr) &#123; if (attr.name.indexOf(prefix) === -1) return ; /** * 指令解析 v-on-click=&apos;onClick&apos; 这里的指令名称为 &apos;on&apos;, &apos;click&apos;为指令的参数，onClick 为key */ //移除 &apos;v-&apos; 前缀, 提取指令名称、指令参数 var directiveStr = attr.name.slice(prefix.length + 1), argIndex = directiveStr.indexOf(&apos;-&apos;), directiveName = argIndex === -1 ? directiveStr : directiveStr.slice(0, argIndex), directiveDef = Directives[directiveName], arg = argIndex === -1 ? null : directiveStr.slice(argIndex + 1); /** * 指令表达式解析，即 v-text=&apos;counter&apos; counter的解析 * 这里暂时只考虑包含key的情况 */ var key = attr.value; return directiveDef ? &#123; attr: attr, key: key, dirname: directiveName, definition: directiveDef, argument: arg, /** * 指令本身是一个函数的情况下，更新函数即它本身，否则调用它的update方法 */ update: typeof directiveDef === &apos;function&apos; ? directiveDef : directiveDef.update &#125; : null;&#125;/** * 对象合并 */function extend (child, parent) &#123; parent = parent || &#123;&#125;; child = child || &#123;&#125;; for(var key in parent) &#123; if (parent.hasOwnProperty(key)) &#123; child[key] = parent[key]; &#125; &#125; return child;&#125; 参考来源：https://github.com/xiaofuzi/deep-in-vue/blob/master/src/the-super-tiny-vue.js]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
